#!/usr/bin/env node


"use strict";

var log = require('engram/es5/logger');

var Ok = require('engram/es5/result').Ok;
var Err = require('engram/es5/result').Err;

var is = require('is');
var utils = require('engram/es5/utils');
var request = require('request');
var constants = require('engram/es5/constants');

var message = require('engram/es5/message');

var CACHE = {
	order: [], // -- ordered references to the values in the cache.
	value: {}, // -- the body and res objects for each URI.
	pending: {},

	cachesize: constants.CACHESIZE
};

var update = function update(uri, value) {

	CACHE.value[uri] = value;

	// -- renew the item in the cache at the end.
	CACHE.order.filter(function (entry) {
		return entry !== uri;
	});

	CACHE.order.push(uri);

	// -- remove the oldest items from the cache, keeping it a fixed size.
	while (CACHE.order.length > CACHE.cachesize) {

		var uri = CACHE.order.shift();
		delete CACHE.value[uri];
	}
};

var cacheHit = function cacheHit(uri, callback) {

	log.global.trace({}, 'GET ' + uri + ' (cache hit)');

	if (is.object(CACHE.value[uri].res)) {

		callback(Ok({
			res: CACHE.value[uri].res,
			body: CACHE.value[uri].body
		}));
	} else {

		var err = new TypeError(uri + ' had no request body.');
		callback(Err({ uri: uri, err: err }));
	}
};

{
	var freshRequest;

	(function () {

		var runningCount = 0;

		freshRequest = function freshRequest(uri, options, callback, fresh) {

			// -- too many concurrent requests; wait until some are cleared.
			if (runningCount >= constants.REQUESTCOUNT) {

				stallRequest(uri, options, callback, fresh);
				return;
			} else {
				// -- start a fresh request.

				++runningCount;
				log.global.trace({ fresh: fresh, runningCount: runningCount }, 'GET ' + uri + ' (cache miss)');

				var requestStart = process.hrtime();

				request(uri, options, function (err, res, body) {

					--runningCount;

					// -- not really an error condition; don't include stack.
					if (!is.object(res)) {
						err = uri + ' had no response body.';
					} else {

						res.requestTime = process.hrtime(requestStart)[0];
						res.id = utils.randomDigits(constants.REQUEST_ID_SIZE);
					}

					if (err) {

						constants.BUS.emit(message.URL_RESOLVED, Err({ uri: uri, err: err }));

						update(uri, { res: res, body: body });
						callback(Err({ uri: uri, err: err }));
					} else {

						constants.BUS.emit(message.URL_RESOLVED, Ok({ res: res, body: body }));

						update(uri, { res: res, body: body });
						callback(Ok({ res: res, body: body }));
					}

					delete CACHE.pending[uri];
				});
			}
		};
	})();
}

var cachedRequest = function cachedRequest(uri, options, callback) {
	var fresh = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

	if (CACHE.value.hasOwnProperty(uri) && !fresh) {
		cacheHit(uri, callback);
		return;
	}

	var pending = CACHE.pending[uri];

	if (is.undefined(pending)) {

		CACHE.pending[uri] = new Date().getTime();
		freshRequest(uri, options, callback, fresh);
	} else {

		var difference = new Date().getTime() - pending;
		var isTimely = difference < constants.HTTPTIMEOUT;

		isTimely && !fresh ? stallRequest(uri, options, callback, fresh) : freshRequest(uri, options, callback, fresh);
	}
};

var stallRequest = function stallRequest(uri, options, callback, fresh) {

	setTimeout(cachedRequest.bind({}, uri, options, callback, fresh), constants.REQUESTWAIT);
};

var requestURL = function requestURL(uri, opts, callback) {
	var fresh = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

	if (!opts.hasOwnProperty('user-agent')) {

		opts['user-agent'] = constants.USER_AGENT;
	}

	cachedRequest(uri, opts, callback, fresh);
};

module.exports = requestURL;
