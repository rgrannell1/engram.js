#!/usr/bin/env node


"use strict";

var is = require('is');
var log = require('engram/es5/logger');
var utils = require('engram/es5/utils');

var constants = require('engram/es5/constants');
var message = require('engram/es5/message');

var metrics = {};

metrics.bookmarksPerSecond = function () {

	var amount = 0;
	var startTime;
	var lastTime;
	var hasNewInfo = false;

	constants.BUS.on(message.URL_RESOLVED, function () {

		if (is.undefined(startTime)) {
			startTime = new Date().getTime();
		}

		lastTime = new Date().getTime();
		amount++;

		hasNewInfo = true;
	});

	setInterval(function () {

		if (hasNewInfo) {

			var rate = (amount / ((lastTime - startTime) / constants.SECOND_IN_MS), 2).toFixed(2);

			if (isFinite(rate)) {
				log.stats.info({ perSecond: rate }, 'μ bookmarks per second.');
			}

			hasNewInfo = false;
		}
	}, constants.statRates.bookmarksPerSecond);
};

metrics.secondsPerRequest = function () {

	var totalTime = 0;
	var amount = 0;
	var hasNewInfo = false;

	constants.BUS.on(message.URL_RESOLVED, function (urlResult) {

		urlResult.onOk(function (_ref) {
			var res = _ref.res;
			var body = _ref.body;

			amount++;
			totalTime += res.requestTime || 0;
		});

		hasNewInfo = true;
	});

	setInterval(function () {

		if (hasNewInfo) {

			var averageTime = (totalTime / amount).toFixed(2);

			log.stats.info({ averageTime: averageTime }, 'μ seconds per request.');
			hasNewInfo = false;
		}
	}, constants.statRates.secondsPerRequest);
};

metrics.urlSuccessRate = function () {

	var failed = 0;
	var succeeded = 0;
	var hasNewInfo = false;

	constants.BUS.on(message.URL_RESOLVED, function (urlResult) {

		urlResult.onOk(function () {
			return ++succeeded;
		});
		urlResult.onErr(function () {
			return ++failed;
		});

		hasNewInfo = true;
	});

	setInterval(function () {

		if (hasNewInfo) {

			var averageRate = (succeeded / (failed + succeeded)).toFixed(2);

			log.stats.info({ failed: failed, succeeded: succeeded, averageRate: averageRate }, 'μ url success rate.');
			hasNewInfo = false;
		}
	}, constants.statRates.urlSuccessRate);
};

// -- security-related statistics

metrics.servedIPAddresses = function () {

	var ips = [];

	constants.BUS.on(message.USER_RESOLVED, function (req) {

		var ipResult = utils.getIpAddress(req);

		ipResult.onOk(function (ip) {

			if (ips.indexOf(ip) === -1) {
				ips.push(ip);
			}

			log.stats.debug({ ips: ips }, 'served addresses.');
		});

		// -- probably never going to be called.
		ipResult.onErr(function (err) {
			log.global.error({ err: err }, 'could not extract ip address.');
		});
	});
};

metrics.osMemoryUsage = function () {

	setInterval(function () {

		var used = process.memoryUsage();
		var percentage = (100 * (used.heapUsed / used.heapTotal)).toFixed(2);

		log.stats.info({

			percentageUsed: percentage + '%'

		}, 'current memory usage.');
	}, constants.statRates.osMemoryUsage);
};

metrics.concurrentDownloads = function () {

	var count = NaN;

	constants.BUS.on(message.REQUEST_ENDED, function (_ref2) {
		var runningCount = _ref2.runningCount;

		count = runningCount;
	});

	setInterval(function () {

		if (count === count) {
			log.stats.info({ count: count }, 'concurrent downloads.');
		}
	}, constants.statRates.concurrentDownloads);
};

Object.keys(metrics).forEach(function (statname) {
	metrics[statname]();
});
