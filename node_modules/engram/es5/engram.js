#!/usr/bin/env node


"use strict";

var log = require('engram/es5/logger');

var is = require('is');
var fs = require('fs');
var path = require('path');
var http = require('http');
var https = require('https');
var express = require('express');

var Result = require('engram/es5/result').Result;

var pem = require('pem');

var routes = require('engram/es5/routes');
var constants = require('engram/es5/constants');

var createTables = require('engram/es5/create-tables');

var startDaemons = require('engram/es5/start-daemons');
var exitHandler = require('engram/es5/exit-handler');

var createCredentials = function createCredentials(keypath, certpath) {

	log.global.info('creating credentials.');

	pem.createCertificate({

		days: constants.CERT_EXPIRATION,
		selfSigned: true,

		keyBitsize: constants.CERT_KEYSIZE,
		commonName: constants.CERT_COMMONNAME,
		country: constants.CERT_COUNTRY

	}, function (err, keys) {

		if (err) {

			log.global.fatal({ message: err.message, stack: err.stack }, 'failed to generate certificates.');
			process.exit(1);
		}

		fs.writeFileSync(keypath, keys.serviceKey);
		fs.writeFileSync(certpath, keys.certificate);
	});
};

var loadCredentials = function loadCredentials(keypath, certpath) {

	return {
		key: fs.readFileSync(keypath, 'utf8').toString(),
		cert: fs.readFileSync(certpath, 'utf8').toString()
	};
};

var startServer = function startServer(app, port, start, keypath, certpath, callback) {

	callback(Result.of(function () {

		process.on('uncaughtException', exitHandler.bind({}, true));

		app.http.all('*', function (req, res) {

			var originalUrl = 'http://' + req.headers.host + req.originalUrl;

			var httpsURL = ('https://' + req.headers.host + req.originalUrl).replace(':' + port, ':' + (port + 1));

			log.global.info('GET ' + req.originalUrl);
			log.global.info('redirecting ' + originalUrl + ' -> ' + httpsURL);

			res.writeHead(301, {
				Location: httpsURL
			});
			res.end();
		});

		app.https.use('/api', routes.api).use('/', routes.app).use('/', routes.save).on('error', function (err) {

			var handled = {
				EADDRINUSE: 'port ' + port + ' currently in use'
			};

			handled.hasOwnProperty(err.code) ? log.global.error(handled[err.code]) : log.global.error(err.toString());
		});

		if (start) {

			var server;

			try {

				server = {
					http: http.createServer(app.http),
					https: https.createServer(loadCredentials(keypath, certpath), app.https)
				};
			} catch (err) {

				var messages = [{
					pattern: ':UI_set_result:result too small',
					output: 'type your password correctly, clumsy.'
				}, {
					pattern: 'digital envelope routines:EVP_DecryptFinal_ex:bad decrypt',
					output: 'type your password correctly, clumsy.'
				}];

				messages.forEach(function (message) {

					if (err.message.indexOf(message.pattern) !== -1) {

						log.global.fatal(message.output);
						process.exit(1);
					}
				});

				throw err;
				process.exit(1);
			}

			server.http.listen(port, 'localhost', function () {
				log.global.info('http engram listening on port ' + port);
			});

			server.https.listen(port + 1, 'localhost', function () {
				log.global.info('https engram listening on port ' + (port + 1));
			});
		}
	}));
};

/*
	the processes to keep running indefinitely. A single moniter checks each of these
	processes is responding. Each moniter manages its own task lifespans, and logging.

	current tasks:

*/

var daemons = {
	//	status:   daemonStatus,
	//	softFail: daemonSoftFail,
	//	title:    daemonTitle,
	//	archive:  daemonArchive
};

var startApp = function startApp(args) {

	global.DATABASE = args.dbpath;

	var app = {
		http: express(),
		https: express()
	};

	createTables(function (result) {

		// -- fatal error.
		if (result && result.isErr) {
			throw result.fromErr;
		}

		return startServer(app, args.port, args.start, args.keypath, args.certpath, function (result) {

			// -- fatal error.
			if (result && result.isErr) {
				throw result.fromErr;
			}

			startDaemons(daemons);
		});
	});

	return app;
};

var wipeData = function wipeData(args) {

	if (args.logs) {

		wipeData.logs(args);
	} else if (args.db) {

		wipeData.database(args);
	}
};

wipeData.logs = function (args) {

	log.global.info('erasing logs.');

	fs.readdirSync('log').forEach(function (file) {
		fs.unlink(path.join('log', file), function (err) {

			if (err) {
				log.global.error({ message: err.message, stack: err.stack }, 'failed to delete ' + file);
			}
		});
	});
};

wipeData.database = function (args) {

	log.global.info('erasing database.');

	var databasePath = 'data';

	fs.readdirSync(databasePath).filter(function (fname) {
		return ['data-bookmarks.json'].indexOf(fname) === -1;
	}).forEach(function (file) {
		fs.unlink(path.join(databasePath, file), function (err) {

			if (err) {
				log.global.error({ message: err.message, stack: err.stack }, 'failed to delete ' + file);
			}
		});
	});
};

var engram = function engram(args) {

	if (args.wipe) {
		wipeData(args);
	} else if (args.certs) {
		createCredentials(args.keypath, args.certpath);
	} else {

		args.start = is.boolean(args.start) ? args.start : true;

		return startApp(args);
	}
};

module.exports = engram;
