#!/usr/bin/env node


"use strict";

var log = require('engram/es5/logger');

var is = require('is');
var fs = require('fs');
var path = require('path');
var http = require('http');
var https = require('https');
var express = require('express');

var Result = require('engram/es5/result').Result;
var Ok = require('engram/es5/result').Ok;

var routes = require('engram/es5/routes');
var constants = require('engram/es5/constants');

var createTables = require('engram/es5/create-tables');
var redirectToHttps = require('engram/es5/redirect-to-https');
var tagRequest = require('engram/es5/tag-request');

var wipeData = require('engram/es5/wipe-data');

var createCredentials = require('engram/es5/create-credentials');
var guardUser = require('engram/es5/guard-user');
var requestAuth = require('engram/es5/request-auth');

var startDaemons = require('engram/es5/start-daemons');
var exitHandler = require('engram/es5/exit-handler');

require('./err-logger');

var loadCredentials = function loadCredentials(keypath, certpath) {

	return {
		key: fs.readFileSync(keypath, 'utf8').toString(),
		cert: fs.readFileSync(certpath, 'utf8').toString()
	};
};

var attachRoutes = function attachRoutes(app, port) {

	app.http.use(tagRequest).all('*', redirectToHttps(port)).all('*', guardUser);

	app.https.all('*', guardUser).all('*', requestAuth);

	app.https.use(tagRequest).use('/api', routes.api).use('/', routes.app).use('/', routes.save).on('error', function (err) {

		var handled = {
			EADDRINUSE: 'port ' + port + ' currently in use'
		};

		handled.hasOwnProperty(err.code) ? log.global.error(handled[err.code]) : log.global.error(err, 'uncaught error while setting up routes');
	});

	return app;
};

var listenServers = function listenServers(server, port) {

	server.http.listen(port, 'localhost', function () {
		log.global.info('Engram (HTTP) listening on port ' + port);
	});

	server.https.listen(port + 1, 'localhost', function () {
		log.global.info('Engram (HTTPS) listening on port ' + (port + 1));
	});
};

listenServers.precond = function (server, port) {
	is.always.number(port);
};

var setupServer = function setupServer(app, keypath, certpath, callback) {

	setupServer.precond(app, keypath, certpath, callback);

	var loadResult = Result.of(function () {

		return {
			http: http.createServer(app.http),
			https: https.createServer(loadCredentials(keypath, certpath), app.https)
		};
	});

	loadResult.onOk(function (val) {
		callback(Ok(val));
	});

	loadResult.onErr(function (err) {

		;[{
			pattern: ':UI_set_result:result too small',
			output: 'type your password correctly, clumsy.'
		}, {
			pattern: 'digital envelope routines:EVP_DecryptFinal_ex:bad decrypt',
			output: 'type your password correctly, clumsy.'
		}].forEach(function (message) {

			if (err.message.indexOf(message.pattern) !== -1) {

				err.message = message.output;
				callback(Err(err));
			}
		});
	});
};

setupServer.precond = function (app, keypath, certpath, callback) {

	is.always.string(keypath);
	is.always.string(certpath);
	is.always['function'](callback);
};

var startServer = function startServer(app, port, start, keypath, certpath, callback) {

	startServer.precond(app, port, start, keypath, certpath, callback);

	callback(Result.of(function () {

		process.on('uncaughtException', exitHandler.bind({}, true));

		app = attachRoutes(app, port);

		if (!start) {
			return;
		} else {

			setupServer(app, keypath, certpath, function (loadResult) {

				loadResult.onOk(function (servers) {
					listenServers(servers, port);
				});

				loadResult.onErr(function (err) {

					log.global.error(err, 'failed to load servers.');
					process.exit(1);
				});
			});
		}
	}));
};

startServer.precond = function (app, port, start, keypath, certpath, callback) {

	is.always.number(port);
	is.always.boolean(start);
	is.always.string(keypath);
	is.always.string(certpath);
	is.always['function'](callback);
};

/*
	the processes to keep running indefinitely. A single moniter checks each of these
	processes is responding. Each moniter manages its own task lifespans, and logging.

	current tasks:

*/

var daemons = {
	//	status:   daemonStatus,
	//	softFail: daemonSoftFail,
	//	title:    daemonTitle,
	//	archive:  daemonArchive
};

var startApp = function startApp(args) {

	global.DATABASE = args.dbpath; // -- a hack.

	var app = {
		http: express(),
		https: express()
	};

	createTables(function (dbResult) {

		dbResult.onErr(function (err) {

			log.global.fatal(err, 'failed to create database tables.');
			process.exit(1);
		});

		return startServer(app, args.port, args.start, args.keypath, args.certpath, function (startResult) {

			startResult.onErr(function (err) {

				log.global.fatal(err, 'failed to start server.');
				process.exit(1);
			});

			startResult.onOk(function () {
				startDaemons(daemons);
			});
		});
	});

	return app;
};

var callbacks = {};

callbacks.wipeData = function (wipeResult) {

	wipeResult.onOk(function () {

		log.global.info('successfully cleared database or logs.');
		process.exit(0);
	});

	wipeResult.onErr(function (err) {

		log.global.error({ err: err }, 'failed to wipe database or logs.');
		process.exit(1);
	});
};

callbacks.createCredentials = function (writeResult) {

	writeResult.onErr(function (err) {

		log.global.error({

			err: err,
			keypath: args.keypath,
			certpath: args.certpath

		}, 'failed to create https credentials.');

		process.exit(1);
	});
};

var engram = function engram(args) {

	args = engram.preprocess(args);

	if (args.wipe) {

		wipeData(args, callbacks.wipeData);
	} else if (args.certs) {

		createCredentials(args.keypath, args.certpath, callbacks.createCredentials);
	} else {

		return startApp(args);
	}
};

engram.preprocess = function (args) {

	args.start = is.boolean(args.start) ? args.start : true;

	return args;
};

module.exports = engram;
