
"use strict"





var Result = { }

Result.of = fn => {
	return Ok(undefined).then(( ) => fn( ))
}

Result.isResult = val => {
	return is.object(val) && (Result.isErr(val) || Result.isOk(val))
}

Result.isErr = val => {
	is.object(val) && val.isErr === true
}

Result.isOk = val => {
	is.object(val) && val.isOk === true
}

Result.fromErr = ( ) => {

	if (isErr(this)) {
		return this.val
	} else {
		throw TypeError('attempted to extract from non-err object.')
	}

}

Result.fromOk = ( ) => {

	if (isOk(this)) {
		return this.val
	} else {
		throw TypeError('attempted to extract from non-ok object.')
	}

}





var Err = function (val) {
	return {val, isOk: false, isErr: true}
}

Err.prototype.then = fn => {
	return this
}

Err.prototype.tap = fn => {
	return this
}

Err.prototype.onErr = fn => {
	fn(this.val)
	return this
}

Err.prototype.onOk = fn => {
	return this
}

Err.prototype.productOf = ( ) => {
	return this
}

Err.prototype.cross = ( ) => {
	return this
}







var Ok = function (val) {
	return {val, isOk: true, isErr: false}
}

Ok.prototype.onErr = fn => {
	return this
}

Ok.prototype.onOk = fn => {
	fn(this.val)
	return this
}

Ok.prototype.then = fn => {

	try {

		var result = fn(this.val)
		return Result.isResult(result) ? result : Ok(result)

	} catch (err) {
		return Err(err)
	}

}

Ok.prototype.tap = fn => {

	var result = this.then(fn)
	return Result.isErr(result) ? result : this

}

Ok.prototype.cross = results => {

	var vals = [this.val]

	for (var ith = 0; ith < results.length; ++ith) {

		var result = results[ith]

		if ( !Result.isResult(result) ) {

			throw TypeError('not a result object.')

		} else if (Result.isOk(result)) {

			vals.push(result.val)

		} else {
			return result
		}

	}

	return Ok(vals)

}

Ok.prototype.productOf = ( ) => {
	return Ok.prototype.cross(this.value)
}





module.exports = {
	Err,
	Ok,
	Result
}
