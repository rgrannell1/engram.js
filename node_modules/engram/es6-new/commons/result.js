
"use strict"




var of = fn => {
	return Ok(undefined).then(( ) => fn( ))
}

var isResult = val => {
	return is.object(val) && (isErr(val) || isOk(val))
}

var isErr = val => {
	is.object(val) && val.isErr === true
}

var isOk = val => {
	is.object(val) && val.isOk === true
}

var fromOk = ( ) => {

}

var fromErr = ( ) => {

	if (isErr(this)) {
		return this.val
	} else {
		throw TypeError('attempted to extract from non-err object.')
	}

}

var fromOk = ( ) => {

	if (isOk(this)) {
		return this.val
	} else {
		throw TypeError('attempted to extract from non-ok object.')
	}

}





var Result = {
	of,
	isResult,
	isOk,
	isErr,
	fromOk,
	fromErr
}





var Err = val => {

}

Err.prototype.then = fn => {
	return this
}

Err.prototype.tap = fn => {
	return this
}

Err.prototype.onErr = fn => {
	fn(this.val)
	return this
}

Err.prototype.onOk = fn => {
	return this
}

Err.prototype.productOf = ( ) => {
	return this
}

Err.prototype.cross = ( ) => {
	return this
}







var Ok = val => {

	return {

	}

}

Ok.prototype.onErr = fn => {
	return this
}

Ok.prototype.onOk = fn => {
	fn(this.val)
	return this
}

Ok.prototype.then = fn => {

	try {

		var result = fn(this.val)
		return Result.isResult(result) ? result : Ok(result)

	} catch (err) {
		return Err(err)
	}

}

Ok.prototype.tap = fn => {

	var result = this.then(fn)
	return Result.isErr(result) ? result : this

}

Ok.prototype.cross = results => {

}

Ok.prototype.productOf = ( ) => {

}





module.exports = {
	Err,
	Ok,
	Result
}
