#!/usr/bin/env node

"use strict"





var log = require('engram/logger')

var is          = require('is')
var bunyan      = require('bunyan')

var Result      = require('engram/result').Result
var Ok          = require('engram/result').Ok
var Err         = require('engram/result').Err


var routes      = require('engram/routes')
var database    = require('engram/database')
var bookmark    = require('engram/bookmark')

var exitHandler = require('engram/exit-handler')









var parseBookmarks = rows => {

	var bookmarkResults = rows.map(row => bookmark.bookmark(row))

	var fails = bookmarkResults.filter(res => res.isErr)
	var oks   = bookmarkResults.filter(res => res.isOk)

	if (fails.length > 0) {
		logger.warning({fails: JSON.stringify(fails)}, `failed to reparse ${fails.length} bookmarks.`)
	}

	return Ok(oks).productOf( )

}





var sendBookmarks = (res, maxID, rowResult) => {

	rowResult.onErr(err => {

		log.error({
			message: err.message,
			stack:   err.stack,
			maxID
		}, 'bookmark lookup failed.')

		res.status(500)
		res.send(err.message)

	})

	rowResult.onOk(rows => {

		Ok(rows)
		.then(parseBookmarks)
		.then(bookmarks => {

			var nextID = bookmarks.length > 0
				? bookmarks
					.map(book => bookmark.getID(book))
					.reduce((num0, num1) => Math.min(num0, num1)) - 1

				: maxID - 1

			var body = JSON.stringify({data: bookmarks, next_id: nextID})

			res.status(200)
			res.contentType('application/json')
			res.send(body)

		})

	})


}





var fetchBookmarks = (maxID, amount, res) => {

	fetchBookmarks.precond(maxID, amount)





	var callback = sendBookmarks.bind({ }, res, maxID)

	database.serialise(db => {

		// -- do a join to get all relevant information on bookmark.

		var sql = `
		SELECT bookmark.bookmark_id, bookmark.url, bookmark.ctime, url.status_code, url.is_soft_failer, url.title
		FROM bookmark, url, archive
		WHERE bookmark_id <= ?
			AND bookmark.url = url.url
			AND archive.url = url.url
		ORDER BY bookmark_id DESC
		LIMIT ?
		`

		db.all(sql, maxID, amount, (err, rows) => {
			err ? callback(Err(err)) : callback(Ok(rows))
		})

	})

}

fetchBookmarks.precond = (maxID, amount) => {

	is.always.number(maxID)
	is.always.number(amount)

}




module.exports = fetchBookmarks
