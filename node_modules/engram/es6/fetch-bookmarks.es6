#!/usr/bin/env node

"use strict"





var log = require('engram/logger')

var is          = require('is')
var https       = require('https')
var express     = require('express')
var bunyan      = require('bunyan')

var Result      = require('engram/result').Result
var Ok          = require('engram/result').Ok
var Err         = require('engram/result').Err


var routes      = require('engram/routes')
var database    = require('engram/database')
var bookmark    = require('engram/bookmark')

var exitHandler = require('engram/exit-handler')





var parseBookmarks = rows => {

	var bookmarkResults = rows.map(row => bookmark.bookmark(row))

	var fails = bookmarkResults.filter(res => res.isErr)
	var oks   = bookmarkResults.filter(res => res.isOk)

	if (fails.length > 0) {
		logger.warning({fails: JSON.stringify(fails)}, `failed to reparse ${fails.length} bookmarks.`)
	}

	return Ok(oks).productOf( )

}





var sendBookmarks = (res, maxID, rowResult) => {

	rowResult.onErr(err => {

		res.status(500)
		res.send(err.message)

	})



	rowResult
	.then(parseBookmarks)
	.then(bookmarks => {

		var nextID = bookmarks.length > 0
			? bookmarks.reduce((bookmark0, bookmark1) => {

				return bookmark.getID(bookmark1) < bookmark.getID(bookmark0)
					? bookmark1
					: bookmark0

			})
			: maxID + 1

		var body = JSON.stringify({data: bookmarks, next_id: nextID})

		console.log(body)

		res.status(200)

		res.contentType('application/json')
		res.send(body)

	})

}





var fetchBookmarks = (maxID, amount, res) => {

	fetchBookmarks.precond(maxID, amount)

	database.do((db, callback) => {

		var sql = `
		SELECT bookmark_id, url, title, ctime
		FROM bookmarks
		WHERE bookmark_id <= ?
		ORDER BY bookmark_id DESC
		LIMIT ?
		`

		db.all(sql, maxID, amount, (err, rows) => {
			err ? callback(Err(err)) : callback(Ok(rows))
		})

	}, sendBookmarks.bind({ }, res, maxID))

}

fetchBookmarks.precond = (maxID, amount) => {

	is.always.number(maxID)
	is.always.number(amount)

}




module.exports = fetchBookmarks
