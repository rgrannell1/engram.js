#!/usr/bin/env node

"use strict"





var is            = require('is')
var log           = require('engram/logger')

var Result        = require('engram/result').Result
var Ok            = require('engram/result').Ok
var Err           = require('engram/result').Err
var utils         = require('engram/utils')
var stats         = require('engram/stats')




/*

	start(manager, reporter, state)


*/

var start = (manager, reporter, state) => {

	start.precond(manager, reporter, state)

	var reporter2 = (args, state) => {

		reporter2.precond(args, state)
		manager(recall, reporter(args, state))

	}

	reporter2.precond = (args, state) => {
		is.always.object(state)
	}

	var recall = (args, timeout) => {

		recall.precond(args, timeout)
		setTimeout(reporter2.bind({ }, args, state), timeout)

	}

	recall.precond = (args, timeout) => {

		is.always.number(timeout)

		if (timeout !== timeout || timeout === 0) {
			throw Error('invalid value for timeout.')
		}

	}

	manager(recall, state)

}

start.precond = (manager, reporter, state) => {

	is.always.function(manager,  'manager')
	is.always.function(reporter, 'reporter')
	is.always.object(state,      'state')

}





/*
	wrapReporter(reporter)

	wrap a reporter function in a second function.
*/

var wrapReporter = (fn, reporter) => {

	wrapReporter.precond(fn, reporter)

	return (args, state) => {

		fn(args, state)
		return reporter(args, state)

	}

}

wrapReporter.precond = (fn, reporter) => {

	is.always.function(fn)
	is.always.function(reporter)

}




/*
	reportAlive(registry)

*/

var reportAlive = registry => {

	reportAlive.precond(registry)
	registry.push(new Date( ).getTime( ))

}

reportAlive.precond = registry => {
	is.always.array(registry)
}




// -- todo factor stats into reporter.

var startJobs = (jobName, job, registry, stats) => {

	var neverStarted = registry.length === 0

	stats.started          = stats.started          || { }
	stats.started[jobName] = stats.started[jobName] || 0

	if (neverStarted) {

		log.info({ }, `starting ${jobName}.`)

		stats.started[jobName]++

		reportAlive(registry)
		start(job.moniter, wrapReporter(reportAlive.bind({ }, registry), job.reporter), job.state)

	}

}






var restartStalledJobs = (jobName, job, registry, stats) => {

	var now        = new Date( ).getTime( )

	var elapsed    = now - registry[registry.length - 1]
	var isStalled  = elapsed > job.timeout

	if (isStalled) {

		log.info({
			elapsed,
			timeout: job.timeout,
		}, `${jobName} stalled ; restarting.`)

		stats.stalled          = stats.stalled          || { }
		stats.stalled[jobName] = stats.stalled[jobName] || 0
		stats.stalled[jobName]++







		reportAlive(registry)
		start(job.moniter, wrapReporter(reportAlive.bind({ }, registry), job.reporter), job.state)
		return

	}

}







var moniterManager = (recall, state) => {

	// -- create and moniter jobs. Report in the registry.

	try {

		Object.keys(state.jobs).map(jobName => {

			var job      = state.jobs[jobName]
			var registry = (state.registry[jobName] = state.registry[jobName] || [ ])


			startJobs         (jobName, job, registry, state.stats)
			restartStalledJobs(jobName, job, registry, state.stats)

		})

	} catch (err) {

		log.error({message: err.message, stack: err.stack})

	}

	recall(undefined, state.control.delay)

}







/*
	moniterWorkers(jobs)

	given an object containing the jobs to run, keep the jobs
	alive indefinitely.

*/

var moniterWorkers = jobs => {

	moniterWorkers.precond(jobs)


	var moniterReporter = (args, state) => {

		log.info(state.stats, 'task manager')

		return state
	}

	var moniterState = {
		control: {
			delay: 2 * 1000
		},
		registry: { },
		stats:    { },
		jobs
	}

	start(moniterManager, moniterReporter, moniterState)

}

moniterWorkers.precond = jobs => {
	is.always.object(jobs)
}





module.exports = {
	start,
	wrapReporter,
	moniterWorkers
}
