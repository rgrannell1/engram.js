#!/usr/bin/env node

"use strict"





var log           = require('engram/logger')

var Result        = require('engram/result').Result
var Ok            = require('engram/result').Ok
var Err           = require('engram/result').Err

var is            = require('is')
var request       = require('request')

var extractTitle  = require('engram/extract-title')
var createArchive = require('engram/create-archive')
var log           = require('engram/logger')
var constants     = require('engram/constants')





var cache = {
	order:   [ ], // -- ordered references to the values in the cache.
	value:   { }, // -- the body and res objects for each URI.
	pending: { },

	cachesize: constants.CACHESIZE
}







var maintain = cache => {

	while (cache.order.length > cache.cachesize) {

		var uri = cache.order.shift( )
		delete cache.value[uri]

	}

	return cache

}










var cacheHit = (uri, callback) => {

	log.info({ }, `URL lookup (cache hit) ${uri}`)

	callback( Ok({
		res:  cache.value[uri].res,
		body: cache.value[uri].body
	}) )

}




var stallRequest = (uri, options, callback, fresh) => {

	log.info(`URL lookup (pending) ${uri}`)

	setTimeout(
		cachedRequest.bind({ }, uri, options, callback, fresh),
		1 * 1000)

}





{

	var runningCount = 0

	var freshRequest = (uri, options, callback, fresh) => {

		// -- too many concurrent requests; wait until some are cleared.
		if (runningCount >= constants.REQUESTCOUNT) {

			setTimeout(freshRequest.bind({ }, uri, options, callback, fresh), constants.REQUESTWAIT)
			return

		}

		log.info({fresh, runningCount}, `URL lookup (cache miss) ${uri}`)





		++runningCount

		request(uri, options, (err, res, body) => {

			--runningCount

			delete cache.pending[uri]

			if (err) {

				callback( Err({uri, err}) )

			} else {

				cache.value[uri] = {res, body}

				if (cache.order.indexOf(uri) === -1) {
					cache.order.push(uri)
				}

				cache = maintain(cache)

				callback( Ok({res, body}) )

			}

		})

	}

}











var cachedRequest = (uri, options, callback, fresh = false) =>{

	if (cache.value.hasOwnProperty(uri) && !fresh) {
		cacheHit(uri, callback)
	}

	var hasPending = cache.pending.hasOwnProperty(uri)

	if (!hasPending) {

		cache.pending[uri] = new Date( ).getTime( )

		freshRequest(uri, options, callback, fresh)

	} else {

		var difference = new Date( ).getTime( ) - cache.pending[uri]
		var isTimely   = difference < constants.HTTPTIMEOUT

		isTimely && !fresh
			? stallRequest(uri, options, callback, fresh)
			: freshRequest(uri, options, callback, fresh)

	}

}





var requestURL = (uri, opts, callback, fresh = false) => {

	if (!opts.hasOwnProperty('user-agent')) {
		opts['user-agent'] = 'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.43 Safari/537.31'
	}

	try {
		cachedRequest(uri, opts, callback, fresh)
	} catch (err) {
		callback(Err({uri, err}))
	}

}





module.exports = requestURL
