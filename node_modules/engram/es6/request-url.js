#!/usr/bin/env node

"use strict"





var log           = require('engram/logger')

var Result        = require('engram/result').Result
var Ok            = require('engram/result').Ok
var Err           = require('engram/result').Err

var is            = require('is')
var request       = require('request')

var extractTitle  = require('engram/extract-title')
var createArchive = require('engram/create-archive')
var log           = require('engram/logger')
var constants     = require('engram/constants')





var cache = {
	order:   [ ], // -- ordered references to the values in the cache.
	value:   { }, // -- the body and res objects for each URI.
	pending: { },

	cachesize: constants.CACHESIZE
}







var update = (cache, uri, value)  => {

	cache.value[uri] = value

	// -- renew the item in the cache at the end.
	cache.order.filter(entry => {
		return entry !== uri
	})

	cache.order.push(uri)

	// -- remove the oldest items from the cache, keeping it a fixed size.
	while (cache.order.length > cache.cachesize) {

		var uri = cache.order.shift( )
		delete cache.value[uri]

	}

	return cache

}










var cacheHit = (uri, callback) => {

	log.info({ }, `URL lookup (cache hit) ${uri}`)

	callback( Ok({
		res:  cache.value[uri].res,
		body: cache.value[uri].body
	}) )

}




var stallRequest = (uri, options, callback, fresh) => {

	setTimeout(
		cachedRequest.bind({ }, uri, options, callback, fresh),
		constants.REQUESTWAIT)

}





{

	let runningCount = 0

	var freshRequest = (uri, options, callback, fresh) => {

		// -- too many concurrent requests; wait until some are cleared.
		if (runningCount >= constants.REQUESTCOUNT) {

			stallRequest(uri, options, callback, fresh)
			return

		} else {

			++runningCount
			log.info({fresh, runningCount}, `URL lookup (cache miss) ${uri}`)





			request(uri, options, (err, res, body) => {

				delete cache.pending[uri]
				--runningCount

				if (err) {

					callback( Err({uri, err}) )

				} else {

					cache = update(cache, uri, {res, body})

					callback( Ok({res, body}) )

				}

			})

		}

	}

}











var cachedRequest = (uri, options, callback, fresh = false) =>{

	if (cache.value.hasOwnProperty(uri) && !fresh) {
		cacheHit(uri, callback)
	}

	var hasPending = cache.pending.hasOwnProperty(uri)

	if (!hasPending) {

		cache.pending[uri] = new Date( ).getTime( )

		freshRequest(uri, options, callback, fresh)

	} else {

		var difference = new Date( ).getTime( ) - cache.pending[uri]
		var isTimely   = difference < constants.HTTPTIMEOUT

		isTimely && !fresh
			? stallRequest(uri, options, callback, fresh)
			: freshRequest(uri, options, callback, fresh)

	}

}





var requestURL = (uri, opts, callback, fresh = false) => {

	if (!opts.hasOwnProperty('user-agent')) {

		opts['user-agent'] = 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/41.0.2272.76 Chrome/41.0.2272.76 Safari/537.36'


	}

	try {
		cachedRequest(uri, opts, callback, fresh)
	} catch (err) {
		callback(Err({uri, err}))
	}

}





module.exports = requestURL
