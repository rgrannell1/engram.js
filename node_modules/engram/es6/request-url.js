#!/usr/bin/env node

"use strict"





var log           = require('engram/es5/logger')

var Ok            = require('engram/es5/result').Ok
var Err           = require('engram/es5/result').Err

var is            = require('is')
var request       = require('request')
var constants     = require('engram/es5/constants')

var message       = require('engram/es5/message')





var CACHE = {
	order:   [ ], // -- ordered references to the values in the cache.
	value:   { }, // -- the body and res objects for each URI.
	pending: { },

	cachesize: constants.CACHESIZE
}







var update = (uri, value)  => {

	CACHE.value[uri] = value

	// -- renew the item in the cache at the end.
	CACHE.order.filter(entry => {
		return entry !== uri
	})

	CACHE.order.push(uri)

	// -- remove the oldest items from the cache, keeping it a fixed size.
	while (CACHE.order.length > CACHE.cachesize) {

		var uri = CACHE.order.shift( )
		delete CACHE.value[uri]

	}

}










var cacheHit = (uri, callback) => {

	log.global.info({ }, `GET ${uri} (cache hit)`)

	if (is.object(CACHE.value[uri].res)) {

		callback( Ok({
			res:  CACHE.value[uri].res,
			body: CACHE.value[uri].body
		}) )

	} else {

		var err = new TypeError(`${uri} had no request body.`)
		callback( Err({uri, err}) )

	}

}





{

	let runningCount = 0

	var freshRequest = (uri, options, callback, fresh) => {

		// -- too many concurrent requests; wait until some are cleared.
		if (runningCount >= constants.REQUESTCOUNT) {

			stallRequest(uri, options, callback, fresh)
			return

		} else {
			// -- start a fresh request.

			++runningCount
			log.global.info({fresh, runningCount}, `GET ${uri} (cache miss)`)

			var requestStart = process.hrtime( )

			request(uri, options, (err, res, body) => {

				--runningCount

				if (!is.object(res)) {
					// -- not really an error condition; don't include stack.
					err = `${uri} had no response body.`
				} else {
					res.requestTime = process.hrtime(requestStart)[0]
				}

				if (err) {

					constants.BUS.fire( message.URL_RESOLVED, Err({uri, err}) )

					update(uri, {res, body})
					callback( Err({uri, err}) )

				} else {

					constants.BUS.fire( message.URL_RESOLVED, Ok({res, body}) )

					update(uri, {res, body})
					callback( Ok({res, body}) )

				}

				delete CACHE.pending[uri]

			})

		}

	}

}











var cachedRequest = (uri, options, callback, fresh = false) =>{

	if (CACHE.value.hasOwnProperty(uri) && !fresh) {
		cacheHit(uri, callback)
		return
	}

	var pending = CACHE.pending[uri]

	if (is.undefined(pending)) {

		CACHE.pending[uri] = new Date( ).getTime( )
		freshRequest(uri, options, callback, fresh)

	} else {

		var difference = new Date( ).getTime( ) - pending
		var isTimely   = difference < constants.HTTPTIMEOUT

		isTimely && !fresh
			? stallRequest(uri, options, callback, fresh)
			: freshRequest(uri, options, callback, fresh)

	}

}




var stallRequest = (uri, options, callback, fresh) => {

	setTimeout(
		cachedRequest.bind({ }, uri, options, callback, fresh),
		constants.REQUESTWAIT)

}





var requestURL = (uri, opts, callback, fresh = false) => {

	if (!opts.hasOwnProperty('user-agent')) {

		opts['user-agent'] = constants.USER_AGENT
	}

	cachedRequest(uri, opts, callback, fresh)

}





module.exports = requestURL
