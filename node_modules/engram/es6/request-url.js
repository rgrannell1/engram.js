#!/usr/bin/env node

"use strict"





var log           = require('engram/logger')

var Result        = require('engram/result').Result
var Ok            = require('engram/result').Ok
var Err           = require('engram/result').Err

var is            = require('is')
var request       = require('request')

var extractTitle  = require('engram/extract-title')
var constants     = require('engram/constants')





var CACHE = {
	order:   [ ], // -- ordered references to the values in the cache.
	value:   { }, // -- the body and res objects for each URI.
	pending: { },

	cachesize: constants.CACHESIZE
}







var update = (uri, value)  => {

	CACHE.value[uri] = value

	// -- renew the item in the cache at the end.
	CACHE.order.filter(entry => {
		return entry !== uri
	})

	CACHE.order.push(uri)

	// -- remove the oldest items from the cache, keeping it a fixed size.
	while (CACHE.order.length > CACHE.cachesize) {

		var uri = CACHE.order.shift( )
		delete CACHE.value[uri]

	}

}










var cacheHit = (uri, callback) => {

	log.debug({ }, `GET ${uri} (cache hit)`)

	callback( Ok({
		res:  CACHE.value[uri].res,
		body: CACHE.value[uri].body
	}) )

}




var stallRequest = (uri, options, callback, fresh) => {

	setTimeout(
		cachedRequest.bind({ }, uri, options, callback, fresh),
		constants.REQUESTWAIT)

}





{

	let runningCount = 0

	var freshRequest = (uri, options, callback, fresh) => {

		// -- too many concurrent requests; wait until some are cleared.
		if (runningCount >= constants.REQUESTCOUNT) {

			stallRequest(uri, options, callback, fresh)
			return

		} else {
			// -- start a fresh request.

			++runningCount
			log.info({fresh, runningCount}, `GET ${uri} (cache miss)`)

			request(uri, options, (err, res, body) => {

				if (err) {

					callback( Err({uri, err}) )

				} else {

					update(uri, {res, body})

					callback( Ok({res, body}) )

				}

				delete CACHE.pending[uri]
				--runningCount

			})

		}

	}

}











var cachedRequest = (uri, options, callback, fresh = false) =>{

	if (CACHE.value.hasOwnProperty(uri) && !fresh) {
		cacheHit(uri, callback)
	}

	var pending = CACHE.pending[uri]

	if (is.undefined(pending)) {

		CACHE.pending[uri] = new Date( ).getTime( )
		freshRequest(uri, options, callback, fresh)

	} else {

		var difference = new Date( ).getTime( ) - pending
		var isTimely   = difference < constants.HTTPTIMEOUT

		isTimely && !fresh
			? stallRequest(uri, options, callback, fresh)
			: freshRequest(uri, options, callback, fresh)

	}

}





var requestURL = (uri, opts, callback, fresh = false) => {

	if (!opts.hasOwnProperty('user-agent')) {

		opts['user-agent'] = 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/41.0.2272.76 Chrome/41.0.2272.76 Safari/537.36'
	}

	try {
		cachedRequest(uri, opts, callback, fresh)
	} catch (err) {
		callback(Err({uri, err}))
	}

}





module.exports = requestURL
