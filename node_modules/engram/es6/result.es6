#!/usr/bin/env node

"use strict"





var log = require('engram/logger')

try {

	var is = require('is')

} catch (err) {

	log.fatal({
		message: err.message,
		stacK:   err.stack,
	}, 'failed to load dependencies.')

	process.exit( )

}











class Result {

	static of(fn) {
		return Ok(undefined).then(( ) => fn( ))
	}

	static isResult(value) {
		return is.object(value) && (value.isErr === true || value.isOk === true)
	}

	static isErr(value) {
		return is.object(value) && (value.isErr === true)
	}

	static isOk(value) {
		return is.object(value) && (value.isOk === true)
	}

	fromOk ( ) {

		if (Result.isOk(this)) {
			return this.value
		} else {
			throw TypeError('')
		}

	}

	fromErr ( ) {

		if (Result.isErr(this)) {
			return this.value
		} else {
			throw TypeError('')
		}

	}

}




class _Err extends Result {
	constructor(value) {

		if (is.error(value) && true) {
			console.log(value.stack)
			console.log(value.message)
		}

		this.value = Result.isResult(value)
			? value.value
			: value

		this.isErr = true
		this.isOk  = false

		return this

	}

	then(fn) {
		return this
	}

	tap(fn) {
		return this
	}

	onErr(fn) {
		fn(this.value)
		return this
	}

	onOk(fn) {
		return this
	}

	productOf( ) {
		return this
	}

	cross(results) {
		return this
	}

}





class _Ok extends Result {
	constructor(value) {

		this.value = Result.isResult(value)
			? value.value
			: value

		this.isErr = false
		this.isOk  = true

		return this

	}

	onErr(fn) {
		return this
	}

	onOk(fn) {
		fn(this.value)
		return this
	}

	then(fn) {

		try {

			var result = fn(this.value)
			return Result.isErr(result) ? result : Ok(result)

		} catch (err) {
			return Err(err)
		}

	}

	tap(fn) {

		var result = this.then(fn)
		return Result.isErr(result) ? result : this

	}

	cross(results) {

		var values = [this.value]

		for (var ith = 0; ith < results.length; ++ith) {

			if ( !Result.isResult(results[ith]) ) {
				throw TypeError('')
			}

			if (results[ith].isOk) {
				values.push(result.value)
			} else {
				return result
			}

		}

		return Ok(values)

	}

	productOf(results) {

		var values = [ ]

		for (var ith = 0; ith < this.value.length; ++ith) {

			if ( !Result.isResult(results[ith]) ) {
				throw TypeError('')
			}

			if (this.value[ith].isOk) {
				values.push(result.value)
			} else {
				return result
			}

		}

		return Ok(values)

	}

}




// -- to get around the constructor without new problem
var Ok = value => {
	return new _Ok(value)
}

var Err = value => {
	return new _Err(value)
}




module.exports = {
	Err,
	Ok,
	Result
}
