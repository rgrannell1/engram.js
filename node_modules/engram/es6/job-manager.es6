#!/usr/bin/env node

"use strict"





var is            = require('is')
var log           = require('engram/logger')

var Result        = require('engram/result').Result
var Ok            = require('engram/result').Ok
var Err           = require('engram/result').Err
var utils         = require('engram/utils')
var stats         = require('engram/stats')

var manager       = require('engram/manager')









/*
	reportAlive(registry)

	push a new timestamp to the registry, indicating that the task
	is still responding.

*/

var reportAlive = registry => {

	reportAlive.precond(registry)

	registry.push(new Date( ).getTime( ))

}

reportAlive.precond = registry => {
	is.always.array(registry)
}





var startJob = (jobName, job, registry) => {

	var neverStarted = registry.length === 0

	if (neverStarted) {

		log.info({ }, `starting ${jobName}.`)

		manager.start(job.moniter, manager.wrapReporter(reportAlive.bind({ }, registry), job.reporter), job.state)
		reportAlive(registry)

	}

	return neverStarted

}

var restartStalledJob = (jobName, job, registry, stats) => {

	var now        = new Date( ).getTime( )

	var elapsed    = now - registry[registry.length - 1]
	var isStalled  = elapsed > job.timeout

	if (isStalled) {

		log.info({
			elapsed,
			timeout: job.timeout,
		}, `${jobName} stalled ; restarting.`)

		manager.start(job.moniter, manager.wrapReporter(reportAlive.bind({ }, registry), job.reporter), job.state)
		reportAlive(registry)

	}

	return isStalled
}







var moniterManager = (recall, state) => {

	// -- create and moniter jobs. Report in the registry.

	try {

		var results = Object.keys(state.jobs).map(jobName => {

			var job      = state.jobs[jobName]
			var registry = (state.registry[jobName] = state.registry[jobName] || [ ])

			return {
				jobName,
				wasStarted:   startJob(jobName, job, registry),
				wasRestarted: restartStalledJob(jobName, job, registry)
			}

		})

		var actions = results.filter(({jobName, wasStarted, wasRestarted}) => {
			return wasStarted || wasRestarted
		})

		recall(Ok(actions), state.control.delay)

	} catch (err) {

		log.error({message: err.message, stack: err.stack})
		recall(Err(err), state.control.delay)
		return

	}

}





var moniterReporter = (actions, state) => {

	actions.onErr(err => {
		log.error({message: err.message, stack: err.stack}, 'an error while creating workers.')
	})

	actions.onOk(actions => {

		state.stats.actions = state.stats.actions || [ ]

		if (actions.length > 0) {
			state.stats.actions = state.stats.actions.concat(actions)
		}

	})

	log.info(state.stats, 'task manager')

	return state

}






/*
	moniterWorkers(jobs)

	given an object containing the jobs to run, keep the jobs
	alive indefinitely.

*/

var moniterWorkers = jobs => {

	moniterWorkers.precond(jobs)

	var moniterState = {
		control: {
			delay: 2 * 1000
		},
		registry: { },
		stats:    { },
		jobs
	}

	manager.start(moniterManager, moniterReporter, moniterState)

}

moniterWorkers.precond = jobs => {
	is.always.object(jobs)
}





module.exports = moniterWorkers
