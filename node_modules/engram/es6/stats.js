#!/usr/bin/env node

"use strict"





var is        = require('is')
var fs        = require('fs')
var log       = require('engram/es6/logging/logger')
var utils     = require('engram/es6/utils')

var constants = require('engram/es6/constants')
var message   = require('engram/es6/message')





var metrics = { }




metrics.bookmarksPerSecond = ( ) => {

	var amount = 0
	var startTime
	var lastTime
	var hasNewInfo = false

	constants.BUS.on(message.URL_RESOLVED, ( ) => {

		if (is.undefined(startTime)) {
			startTime = (new Date( )).getTime( )
		}

		lastTime = (new Date( )).getTime( )
		amount++

		hasNewInfo = true

	})

	setInterval(( ) => {

		if (hasNewInfo) {

			var rate = (amount / ((lastTime - startTime) / constants.SECOND_IN_MS), 2).toFixed(2)

			if (isFinite(rate)) {
				log.stats.info({perSecond: rate}, `μ bookmarks per second.`)
			}

			hasNewInfo = false

		}

	}, constants.statRates.bookmarksPerSecond)

}





metrics.secondsPerRequest = ( ) => {

	var totalTime = 0
	var amount    = 0
	var hasNewInfo = false

	constants.BUS.on(message.URL_RESOLVED, urlResult => {

		urlResult.onOk( ({res, body}) => {

			amount++
			totalTime += (res.requestTime || 0)

		})

		hasNewInfo = true

	})

	setInterval(( ) => {

		if (hasNewInfo) {

			var averageTime = (totalTime / amount).toFixed(2)

			log.stats.info({averageTime}, `μ seconds per request.`)
			hasNewInfo = false

		}

	}, constants.statRates.secondsPerRequest)

}





metrics.urlSuccessRate = ( ) => {

	var failed     = 0
	var succeeded  = 0
	var hasNewInfo = false

	constants.BUS.on(message.URL_RESOLVED, urlResult => {

		urlResult.onOk (( ) => ++succeeded)
		urlResult.onErr(( ) => ++failed)

		hasNewInfo = true

	})

	setInterval(( ) => {

		if (hasNewInfo) {

			var averageRate = (succeeded / (failed + succeeded)).toFixed(2)

			log.stats.info({failed, succeeded, averageRate}, `μ url success rate.`)
			hasNewInfo = false

		}

	}, constants.statRates.urlSuccessRate)

}





// -- security-related statistics

metrics.servedIPAddresses = ( ) => {

	var ips = [ ]

	constants.BUS.on(message.USER_RESOLVED, req => {

		var ipResult = utils.getIpAddress(req)

		ipResult.onOk(ip => {

			if (ips.indexOf(ip) === -1) {
				ips.push(ip)
			}

			log.stats.debug({ips}, 'served addresses.')

		})

		// -- probably never going to be called.
		ipResult.onErr(err => {
			log.global.error({err}, 'could not extract ip address.')
		})

	})

}





metrics.osMemoryUsage = ( ) => {

	setInterval(( ) => {

		var used       = process.memoryUsage( )
		var percentage = (100 * (used.heapUsed / used.heapTotal)).toFixed(2)

		log.stats.info({

			percentageUsed: `${percentage}%`

		}, 'current memory usage.')

	}, constants.statRates.osMemoryUsage)

}





metrics.concurrentDownloads = ( ) => {

	var count = NaN;

	constants.BUS.on(message.REQUEST_ENDED, ({runningCount}) => {
		count = runningCount
	})

	setInterval(( ) => {

		if (count === count) {
			log.stats.info({count}, 'concurrent downloads.')
		}

	}, constants.statRates.concurrentDownloads)

}





metrics.databaseSize = ( ) => {

	setInterval(( ) => {

		// -- very bad: remove hard-coding of a parametre.
		fs.stat('data/engram.db', (err, stats) => {

			if (err) {

				log.global.error(`could not load database: ${err.message}`)

			} else {

				var size = (stats.size / (1000 * 1000)).toFixed(2)

				log.stats.info({size}, `database file size (MB).`)

			}

		})

	}, constants.statRates.databaseSize)


}





Object.keys(metrics).forEach(statname => {
	metrics[statname]( )
})
