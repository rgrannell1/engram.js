#!/usr/bin/env node

"use strict"





var log = require('engram/logger')

var is          = require('is')
var bunyan      = require('bunyan')

var Result      = require('engram/result').Result
var Ok          = require('engram/result').Ok
var Err         = require('engram/result').Err


var routes      = require('engram/routes')
var database    = require('engram/database')









var parseBookmarks = rows => {

	var bookmarkResults = rows.map(row => bookmark.bookmark(row))

	var fails = bookmarkResults.filter(res => res.isErr)
	var oks   = bookmarkResults.filter(res => res.isOk)

	if (fails.length > 0) {
		logger.warning({fails: JSON.stringify(fails)}, `failed to reparse ${fails.length} bookmarks.`)
	}

	return Ok(oks).productOf( )

}





var sendBookmarks = (res, maxID, rowResult) => {

	rowResult.onErr(err => {

		res.status(500)
		res.send(err.message)

	})

	rowResult
	.then(parseBookmarks)
	.then(bookmarks => {

		var nextID = bookmarks.length > 0
			? bookmarks
				.map(book => bookmark.getID(book))
				.reduce((num0, num1) => Math.min(num0, num1)) - 1

			: maxID - 1

		var body = JSON.stringify({data: bookmarks, next_id: nextID})

		res.status(200)
		res.contentType('application/json')
		res.send(body)

	})

}





var fetchArchive = (maxID, amount, res) => {

	fetchArchive.precond(maxID, amount)

	database.do((db, callback) => {

		var sql = `
		SELECT content, content_type
		FROM archive
		WHERE archive.url = $url
		LIMIT $limit
		`

		db.run(sql, {

			$url: url,

		}, err => {
			callback(err ? Err(err) : Ok(url))
		})

	}, callback)

}

fetchArchive.precond = (maxID, amount) => {

	is.always.number(maxID)
	is.always.number(amount)

}




module.exports = fetchArchive
