#!/usr/bin/env node

"use strict"





var log           = require('engram/logger')

var Result        = require('engram/result').Result
var Ok            = require('engram/result').Ok
var Err           = require('engram/result').Err

var is            = require('is')

var extractTitle  = require('engram/extract-title')
var createArchive = require('engram/create-archive')
var log           = require('engram/logger')
var database      = require('engram/database')

var requestURL    = require('engram/request-url')





var findTitlelessURLs = callback => {

	var sql = `
	SELECT * FROM url

	WHERE url.title is NULL

	AND url.is_soft_failer == 0
	AND url.status_code NOT IN (403, 404, 410)
	AND url.status_code < 500;
	`
	database.do((db, callback) => {

		db.all(sql, (err, rows) => {
			err ? callback(Err(err)) : callback(Ok(rows))
		})

	}, callback)

}





var findUnresolvedURL = callback => {

	var sql = `
	SELECT * FROM url

	WHERE url.is_soft_failer is NULL
	OR url.status_code is NULL

	LIMIT 1;
	`

	database.do((db, callback) => {

		db.all(sql, (err, rows) => {
			err ? callback(Err(err)) : callback(Ok(rows))
		})

	}, callback)


}





var start = (manager, reporter, state) => {

	var reporter2 = (args, state) => {
		manager(reporter2, reporter(args, state))
	}

	manager(reporter2, state)

}





var updateStatus = (url, statusCode, continuation) => {

	var sql = `
	UPDATE url
	SET status_code=$statusCode
	WHERE url.url = $url
	`

	database.do((db, callback) => {

		db.run(sql, {
			$url:        url,
			$statusCode: statusCode
		})

	}, continuation)

}





var statusManager = (reporter, state) => {

	findUnresolvedURL(urlResult => {

		urlResult
		.then(url => {

			url.length === 0
			? setTimeout(reporter.bind({ }, url, state), state.control.delay)
			: url.map(({url}) => {

				requestURL(url, { }, (err, res, body) => {

					updateStatus(url, res.statusCode, result => {

						setTimeout(reporter.bind({ }, url, state), state.control.delay)

					})

				})

			})

		})

	})

}





var startStatusWorker = ( ) => {

	var state = {
		control: {
			delay: 1000
		},
		stats: {
			noURL: 0
		}
	}

	var reporter = (url, state) => {

		if (url.length === 0){
			state.stats.noURL += 1
		}

		return state
	}

	start(statusManager, reporter, state)

}





var moniterWorkers = ( ) => {

	// -- todo; maybe factor out worker/moniter into pairs;
	// -- moniter controls execution/termination of worker, may
	// -- request new worker? allows rate adjustment, worker termination,
	// -- and external exception handling. this is quite ad-hoc at the moment.

	startStatusWorker( )

}





module.exports = moniterWorkers
