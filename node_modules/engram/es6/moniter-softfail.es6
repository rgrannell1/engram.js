#!/usr/bin/env node

"use strict"





var log          = require('engram/logger')

var Result       = require('engram/result').Result
var Ok           = require('engram/result').Ok
var Err          = require('engram/result').Err

var requestURL   = require('engram/request-url')
var URL          = require('url')

var database     = require('engram/database')









/*
	findUncheckedURL(callback)

	select a URL that doesn't have a soft-fail status.
*/

var findUncheckedURL = callback => {

	var sql = `
	SELECT * FROM url

	WHERE url.is_soft_failer is NULL

	LIMIT 1;
	`

	database.do((db, callback) => {

		db.all(sql, (err, rows) => {
			err ? callback(Err(err)) : callback(Ok(rows))
		})

	}, callback)

}





/*
	updateSoftFail(url, isSoftFailer, callback)

	set the soft-fail status for a URL.
*/

var updateSoftFail = (url, isSoftFailer, callback) => {

	var sql = `UPDATE url SET is_soft_failer=$isSoftFailer WHERE url.url = $url`

	database.do((db, callback) => {

		db.run(sql, {
			$url:          url,
			$isSoftFailer: isSoftFailer
		})

	}, callback)

}





var isErrorCode = function (code) {
	return [403, 404, 410].indexOf(code) !== -1 || code >= 500
}

var base64 = function (length) {

	var charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-'

	var string = ''

	for (var ith = 0; ith < length; ++ith) {
		string += charset.charAt(Math.floor(Math.random( ) * 64))
	}

	return string

}





var randomURLS = (number, url) => {

	var urls = [ ]

	for (var ith = 0; ith < number; ++ith) {

		urls[ith]          = URL.parse(url)
		urls[ith].pathname = urls[ith].pathname.replace(/[^/]*$/, base64(20))
		urls[ith]          = URL.format(urls[ith])

	}

	return urls

}





/*
	isSoftFailer(url, callback)

	does a URL fail with a 200-status? The algorithm used is
	described "Towards an understanding of the web decay."


	* if it succeeds, the page may not be dead.
	* if it redirects, follow ten non-looping steps before declaring dead.
	* if the page succeeds:
	      > create several fake URLs from the parent url.
	      > if (after redirecting) the random urls fail, our URL is valid! Otherwise, soft-failer.
	      > if random & ours redirect the same number of hops, soft failer! If ours if different,
	      ours might be alive.
	      > if, upon shingling, the contents out our URL is the same as outs, probably a soft-failure.
	      > can also look for '404' or 'not found in title', false positive.

*/

var isSoftFailer = (url, Return) => {
	// -- TODO



}




/*
	saveSoftFailStatus(recall, state, url)


*/

var saveSoftFailStatus = (recall, state, url) => {

	url.length === 0
		? recall(undefined, state.control.delay)
		: isSoftFailer(statusResult => {
			updateSoftFail( url )
		})

}





/*
	save a single unresolved URLs softfail status to the database before recalling.
*/

var moniter = (recall, state) => {
	findUnresolvedURL(urlResult => {

		urlResult.then(saveStatus.bind({ }, recall, state))

	})
}





var state = {
	control: {
		delay: 1000
	},
	stats: {

	}
}
