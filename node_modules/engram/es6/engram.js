#!/usr/bin/env node

"use strict"





var log               = require('engram/es5/logger')

var is                = require('is')
var fs                = require('fs')
var path              = require('path')
var http              = require('http')
var https             = require('https')
var express           = require('express')

var Result            = require('engram/es5/result').Result

var routes            = require('engram/es5/routes')
var constants         = require('engram/es5/constants')

var createTables      = require('engram/es5/create-tables')
var redirectToHttps   = require('engram/es5/redirect-to-https')
var tagRequest        = require('engram/es5/tag-request')

var createCredentials =require('engram/es5/create-credentials')
var guardUser         = require('engram/es5/guard-user')
var requestAuth       = require('engram/es5/request-auth')

var startDaemons      = require('engram/es5/start-daemons')
var exitHandler       = require('engram/es5/exit-handler')

require('./err-logger')




var loadCredentials = (keypath, certpath) => {

	return {
		key:  fs.readFileSync(keypath,  'utf8').toString( ),
		cert: fs.readFileSync(certpath, 'utf8').toString( )
	}

}









var startServer = (app, port, start, keypath, certpath, callback) => {

	callback( Result.of(( ) => {

		process.on('uncaughtException', exitHandler.bind({ }, true))





		app.http
		.use(tagRequest)
		.all('*', redirectToHttps(port))
		.all('*', guardUser)

		app.https
		.all('*', guardUser)
		.all('*', requestAuth)

		app.https
		.use(tagRequest)
		.use('/api', routes.api)
		.use('/',    routes.app)
		.use('/',    routes.save)
		.on('error', err => {

			var handled = {
				EADDRINUSE: `port ${port} currently in use`
			}

			handled.hasOwnProperty(err.code)
				? log.global.error(handled[err.code])
				: log.global.error(err.toString( ))

		})


		if (!start) {
			return
		}

		var server

		try {

			server = {
				http:  http.createServer(app.http),
				https: https.createServer(loadCredentials(keypath, certpath), app.https)
			}

		} catch (err) {

			var messages = [
				{
					pattern: ':UI_set_result:result too small',
					output: 'type your password correctly, clumsy.'
				},
				{
					pattern: 'digital envelope routines:EVP_DecryptFinal_ex:bad decrypt',
					output: 'type your password correctly, clumsy.'
				}
			]

			messages.forEach(function (message) {

				if (err.message.indexOf(message.pattern) !== -1) {

					log.global.fatal(message.output)
					process.exit(1)

				}


			})

			throw err
			process.exit(1)

		}


		server.http.listen(port, 'localhost', ( ) => {
			log.global.info(`http engram listening on port ${port}`)
		})

		server.https.listen(port + 1, 'localhost', ( ) => {
			log.global.info(`https engram listening on port ${port + 1}`)
		})

	}) )

}






/*
	the processes to keep running indefinitely. A single moniter checks each of these
	processes is responding. Each moniter manages its own task lifespans, and logging.

	current tasks:

*/

var daemons = {
//	status:   daemonStatus,
//	softFail: daemonSoftFail,
//	title:    daemonTitle,
//	archive:  daemonArchive
}





var startApp = function (args) {

	global.DATABASE = args.dbpath

	var app = {
		http:  express( ),
		https: express( )
	}

	createTables(result => {

		// -- fatal error.
		if (result && result.isErr) {
			throw result.fromErr
		}

		return startServer(app, args.port, args.start, args.keypath, args.certpath, result => {

			// -- fatal error.
			if (result && result.isErr) {
				throw result.fromErr
			}

			startDaemons(daemons)

		})

	})

	return app


}





var wipeData = function (args) {

	if (args.logs) {

		wipeData.logs(args)

	} else if (args.db) {

		wipeData.database(args)

	}

}

wipeData.logs = function (args) {

	log.global.info(`erasing logs.`)

	fs.readdirSync('log').forEach(file => {
		fs.unlink(path.join('log', file), err => {

			if (err) {
				log.global.error({err}, `failed to delete ${file}`)
			}

		})
	})

}

wipeData.database = function (args) {

	log.global.info(`erasing database.`)

	var databasePath = 'data'

	fs.readdirSync(databasePath)
	.filter(fname => {
		return ['data-bookmarks.json', 'ip-whitelist'].indexOf(fname) === -1
	})
	.forEach(file => {
		fs.unlink(path.join(databasePath, file), err => {

			if (err) {
				log.global.error({err}, `failed to delete ${file}`)
			}

		})
	})

}






var engram = (args) => {

	if (args.wipe) {
		wipeData(args)
	} else if (args.certs) {

		createCredentials(args.keypath, args.certpath, writeResult => {

		})

	} else {

		args.start = is.boolean(args.start)
			? args.start
			: true

		return startApp(args)

	}

}





module.exports = engram
