#!/usr/bin/env node

"use strict"





var log             = require('engram/logger')

var is              = require('is')
var http            = require('http')
var express         = require('express')

var Result          = require('engram/result').Result
var Ok              = require('engram/result').Ok
var Err             = require('engram/result').Err

var routes          = require('engram/routes')
var database        = require('engram/database')

var createTables    = require('engram/create-tables')

var daemonStatus    = require('engram/daemon-status')
var daemonSoftFail  = require('engram/daemon-softfail')
var daemonTitle     = require('engram/daemon-title')
var daemonArchive   = require('engram/daemon-archive')

var startDaemons    = require('engram/start-daemons')
var exitHandler     = require('engram/exit-handler')










var startServer = (app, port, start, callback) => {

	callback( Result.of(( ) => {

		process.on('uncaughtException', exitHandler.bind({ }, true))

		app
		.use('/api', routes.api)
		.use('/',    routes.app)
		.use('/',    routes.save)
		.on('error', err => {

			var handled = {
				EADDRINUSE: `port ${port} currently in use`
			}

			handled.hasOwnProperty(err.code)
				? log.error(handled[err.code])
				: log.error(err.toString( ))

		})

		if (start) {

			app.listen(port, 'localhost', ( ) => {
				log.info(`engram listening on port ${port}`)
			})

		}

	}) )

}






/*
	the processes to keep running indefinitely. A single moniter checks each of these
	processes is responding. Each moniter manages its own task lifespans, and logging.

	current tasks:

*/

var daemons = {
//	status:   daemonStatus,
//	softFail: daemonSoftFail,
//	title:    daemonTitle,
//	archive:  daemonArchive
}





var engram = ({port, dbpath, start}) => {

	engram.precond(port, dbpath)

	start = is.boolean(start)
		? start
		: true

	global.DATABASE = dbpath





	var app = express( )

	createTables(result => {

		// -- fatal error.
		if (result && result.isErr) {
			throw result.fromErr
		}

		return startServer(app, port, start, result => {

			// -- fatal error.
			if (result && result.isErr) {
				throw result.fromErr
			}

			startDaemons(daemons)

  		})

	})

	return app

}

engram.precond = (port, dbpath) => {
	is.always.string(dbpath)
}




module.exports = engram
