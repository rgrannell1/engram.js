#!/usr/bin/env node
"use strict";

var log = require("engram/logger");

var is = require("is");
var bunyan = require("bunyan");

var Result = require("engram/result").Result;
var Ok = require("engram/result").Ok;
var Err = require("engram/result").Err;

var routes = require("engram/routes");
var database = require("engram/database");
var bookmark = require("engram/bookmark");

var exitHandler = require("engram/exit-handler");

var parseBookmarks = function (rows) {

	var bookmarkResults = rows.map(bookmark.bookmark);

	var fails = bookmarkResults.filter(function (res) {
		return res.isErr;
	});
	var oks = bookmarkResults.filter(function (res) {
		return res.isOk;
	});

	if (fails.length > 0) {
		logger.warning({ fails: JSON.stringify(fails) }, "failed to reparse " + fails.length + " bookmarks.");
	}

	return Ok(oks).productOf();
};

var sendBookmarks = function (res, maxID, rowResult) {

	rowResult.onErr(function (err) {

		log.global.error({
			message: err.message,
			stack: err.stack,
			maxID: maxID
		}, "bookmark lookup failed.");

		res.status(500);
		res.send(err.message);
	});

	rowResult.onOk(function (rows) {

		Ok(rows).then(parseBookmarks).then(function (bookmarks) {

			var nextID = bookmarks.length > 0 ? bookmarks.map(function (book) {
				return bookmark.getID(book);
			}).reduce(function (num0, num1) {
				return Math.min(num0, num1);
			}) - 1 : maxID - 1;

			var body = JSON.stringify({ data: bookmarks, next_id: nextID });

			res.status(200);
			res.contentType("application/json");
			res.send(body);
		});
	});
};

var fetchBookmarks = function (maxID, amount, res) {

	fetchBookmarks.precond(maxID, amount);

	var callback = sendBookmarks.bind({}, res, maxID);

	database.serialise(function (db) {

		// -- do a join to get all relevant information on bookmark.

		var sql = "\n\t\tSELECT bookmark.bookmarkId, bookmark.url, bookmark.ctime, url.status_code, url.is_soft_failer, url.title\n\t\tFROM bookmark, url, archive\n\t\tWHERE bookmarkId <= ?\n\t\t\tAND bookmark.url = url.url\n\t\t\tAND archive.url = url.url\n\t\tORDER BY bookmarkId DESC\n\t\tLIMIT ?\n\t\t";

		db.all(sql, maxID, amount, function (err, rows) {
			err ? callback(Err(err)) : callback(Ok(rows));
		});
	});
};

fetchBookmarks.precond = function (maxID, amount) {

	is.always.number(maxID);
	is.always.number(amount);
};

module.exports = fetchBookmarks;