#!/usr/bin/env node
"use strict";

var is = require("is");
var log = require("engram/logger");

var Result = require("engram/result").Result;
var Ok = require("engram/result").Ok;
var Err = require("engram/result").Err;
var utils = require("engram/utils");
var stats = require("engram/stats");

var manager = require("engram/manager");

/*
	reportAlive(registry)

	push a new timestamp to the registry, indicating that the task
	is still responding.

*/

var reportAlive = function (registry) {

	reportAlive.precond(registry);

	registry.push(new Date().getTime());
};

reportAlive.precond = function (registry) {
	is.always.array(registry);
};

var startJob = function (jobName, job, registry) {

	var neverStarted = registry.length === 0;

	if (neverStarted) {

		log.info({}, "starting " + jobName + ".");

		manager.start(job.moniter, manager.wrapReporter(reportAlive.bind({}, registry), job.reporter), job.state);
		reportAlive(registry);
	}

	return neverStarted;
};

var restartStalledJob = function (jobName, job, registry, stats) {

	var now = new Date().getTime();

	var elapsed = now - registry[registry.length - 1];
	var isStalled = elapsed > job.timeout;

	if (isStalled) {

		log.info({
			elapsed: elapsed,
			timeout: job.timeout }, "" + jobName + " stalled ; restarting.");

		manager.start(job.moniter, manager.wrapReporter(reportAlive.bind({}, registry), job.reporter), job.state);
		reportAlive(registry);
	}

	return isStalled;
};

var moniterManager = function (recall, state) {

	// -- create and moniter jobs. Report in the registry.

	try {

		var results = Object.keys(state.jobs).map(function (jobName) {

			var job = state.jobs[jobName];
			var registry = state.registry[jobName] = state.registry[jobName] || [];

			return {
				jobName: jobName,
				wasStarted: startJob(jobName, job, registry),
				wasRestarted: restartStalledJob(jobName, job, registry)
			};
		});

		var actions = results.filter(function (_ref) {
			var jobName = _ref.jobName;
			var wasStarted = _ref.wasStarted;
			var wasRestarted = _ref.wasRestarted;

			return wasStarted || wasRestarted;
		});

		recall(Ok(actions), state.control.delay);
	} catch (err) {

		log.error({ message: err.message, stack: err.stack });
		recall(Err(err), state.control.delay);
		return;
	}
};

var moniterReporter = function (actions, state) {

	actions.onErr(function (err) {
		log.error({ message: err.message, stack: err.stack }, "an error while creating workers.");
	});

	actions.onOk(function (actions) {

		state.stats.actions = state.stats.actions || [];

		if (actions.length > 0) {
			state.stats.actions = state.stats.actions.concat(actions);
		}
	});

	log.info(state.stats, "task manager");

	return state;
};

/*
	moniterWorkers(jobs)

	given an object containing the jobs to run, keep the jobs
	alive indefinitely.

*/

var moniterWorkers = function (jobs) {

	moniterWorkers.precond(jobs);

	var moniterState = {
		control: {
			delay: 2 * 1000
		},
		registry: {},
		stats: {},
		jobs: jobs
	};

	manager.start(moniterManager, moniterReporter, moniterState);
};

moniterWorkers.precond = function (jobs) {
	is.always.object(jobs);
};

module.exports = moniterWorkers;