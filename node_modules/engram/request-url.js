#!/usr/bin/env node
"use strict";

var log = require("engram/logger");

var Result = require("engram/result").Result;
var Ok = require("engram/result").Ok;
var Err = require("engram/result").Err;

var is = require("is");
var request = require("request");

var extractTitle = require("engram/extract-title");
var constants = require("engram/constants");

var message = require("engram/message");

var CACHE = {
	order: [], // -- ordered references to the values in the cache.
	value: {}, // -- the body and res objects for each URI.
	pending: {},

	cachesize: constants.CACHESIZE
};

var update = function (uri, value) {

	CACHE.value[uri] = value;

	// -- renew the item in the cache at the end.
	CACHE.order.filter(function (entry) {
		return entry !== uri;
	});

	CACHE.order.push(uri);

	// -- remove the oldest items from the cache, keeping it a fixed size.
	while (CACHE.order.length > CACHE.cachesize) {

		var uri = CACHE.order.shift();
		delete CACHE.value[uri];
	}
};

var cacheHit = function (uri, callback) {

	log.global.info({}, "GET " + uri + " (cache hit)");

	if (is.object(CACHE.value[uri].res)) {

		callback(Ok({
			res: CACHE.value[uri].res,
			body: CACHE.value[uri].body
		}));
	} else {

		var err = new TypeError("" + uri + " had no request body.");
		callback(Err({ uri: uri, err: err }));
	}
};

{
	var freshRequest;

	(function () {

		var runningCount = 0;

		freshRequest = function (uri, options, callback, fresh) {

			// -- too many concurrent requests; wait until some are cleared.
			if (runningCount >= constants.REQUESTCOUNT) {

				stallRequest(uri, options, callback, fresh);
				return;
			} else {
				// -- start a fresh request.

				++runningCount;
				log.global.info({ fresh: fresh, runningCount: runningCount }, "GET " + uri + " (cache miss)");

				request(uri, options, function (err, res, body) {

					--runningCount;

					if (!is.object(res)) {
						err = new TypeError("" + uri + " was not defined.");
					}

					if (err) {

						constants.BUS.fire(message.URL_RESOLVED, Err({ uri: uri, err: err }));

						update(uri, { res: res, body: body });
						callback(Err({ uri: uri, err: err }));
					} else {

						constants.BUS.fire(message.URL_RESOLVED, Err({ res: res, body: body }));

						update(uri, { res: res, body: body });
						callback(Ok({ res: res, body: body }));
					}

					delete CACHE.pending[uri];
				});
			}
		};
	})();
}

var cachedRequest = function (uri, options, callback) {
	var fresh = arguments[3] === undefined ? false : arguments[3];

	if (CACHE.value.hasOwnProperty(uri) && !fresh) {
		cacheHit(uri, callback);
		return;
	}

	var pending = CACHE.pending[uri];

	if (is.undefined(pending)) {

		CACHE.pending[uri] = new Date().getTime();
		freshRequest(uri, options, callback, fresh);
	} else {

		var difference = new Date().getTime() - pending;
		var isTimely = difference < constants.HTTPTIMEOUT;

		isTimely && !fresh ? stallRequest(uri, options, callback, fresh) : freshRequest(uri, options, callback, fresh);
	}
};

var stallRequest = function (uri, options, callback, fresh) {

	setTimeout(cachedRequest.bind({}, uri, options, callback, fresh), constants.REQUESTWAIT);
};

var requestURL = function (uri, opts, callback) {
	var fresh = arguments[3] === undefined ? false : arguments[3];

	if (!opts.hasOwnProperty("user-agent")) {

		opts["user-agent"] = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/41.0.2272.76 Chrome/41.0.2272.76 Safari/537.36";
	}

	cachedRequest(uri, opts, callback, fresh);
};

module.exports = requestURL;