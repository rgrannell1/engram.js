
"use strict"




var is     = require('is')
var errors = require('engram/commons/errors')





var Result = { }

Result.of = function (fn) {
	return Ok(undefined).then(( ) => fn( ))
}

Result.isResult = val => {
	return is.object(val) && (Result.isErr(val) || Result.isOk(val))
}

Result.isErr = val => {
	return is.object(val) && val.isErr === true
}

Result.isOk = val => {
	return is.object(val) && val.isOk === true
}

Result.fromErr = function ( ) {

	if (Result.isErr(this)) {
		return this.val
	} else {
		throw TypeError(errors.ERR_RESULT_REQUIRED)
	}

}

Result.fromOk = function ( ) {

	if (Result.isOk(this)) {
		return this.val
	} else {
		throw TypeError(errors.OK_RESULT_REQUIRED)
	}

}

Result.productOf = results => {

	var vals = [ ]

	for (var ith = 0; ith < results.length; ++ith) {

		if ( !Result.isResult(results[ith]) ) {
			throw TypeError(errors.RESULT_REQUIRED)
		}

		if (results[ith].isOk) {
			vals.push(results[ith].val)
		} else {
			return results[ith]
		}

	}

	return Ok(vals)

}





var Err = function (val) {

	if (!(this instanceof Err)) {
		return new Err(val)
	}

	this.val   = val
	this.isErr = true
	this.isOk  = false

	return this

}

Err.prototype.then = function (fn) {
	return this
}

Err.prototype.tap = function (fn) {
	return this
}

Err.prototype.onErr = function (fn) {
	fn(this.val)
	return this
}

Err.prototype.onOk = function (fn) {
	return this
}





var Ok = function (val) {

	if (!(this instanceof Ok)) {
		return new Ok(val)
	}

	this.val   = val
	this.isErr = false
	this.isOk  = true

	return this

}

Ok.prototype.onErr = function (fn) {
	return this
}

Ok.prototype.onOk = function (fn) {
	fn(this.val)
	return this
}

Ok.prototype.then = function (fn) {

	try {

		var result = fn(this.val)
		return Result.isResult(result) ? result : Ok(result)

	} catch (err) {
		return Err(err)
	}

}

Ok.prototype.tap = function (fn) {

	var result = this.then(fn)
	return Result.isErr(result) ? result : this

}





module.exports = {
	Err,
	Ok,
	Result
}
